<assignment>
    <style>
        assignment steps step h1 {
            min-height: 3.5rem;
            display: flex;
            align-items: center;
            box-sizing: border-box;            
        }
        @keyframes stepAppears {
            from {opacity:0;}
        }

        #uPlotOverlay {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.5rem;
            margin: 0.75rem;
            color: #fff;
            z-index: 10;
            pointer-events: none;
        }
        
        .imageAssetUploader {
            background: rgba(255,255,255,0.1);
            width: 100%;
            position: relative;
            transition: opacity 0.3s ease-in-out;
            margin-bottom: 1em;
        }
        .imageAssetUploader:after {
            content: "-> Drag Files Here <-";
            display: block;
            text-align: center;
            padding: 1em;
            opacity: 0.3;
        }
        .imageAssetUploader[transient-class="uploading"]{
            opacity: 0.6;
        }
        .imageAssetUploader[transient-class="highlight"]{
            background: rgba(200, 200, 255, 0.6);
        }
        .imageAssetUploader[transient-class="uploading"]:after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            width: 3em;
            height: 3em;
            background: pink;
            opacity: 0.6;
        }
        .imageAssetUploader .preview {
            display: flex;
            flex-direction: row;
            align-items: center;
            border: 1px solid #0000513d;
            margin: 2px;
        }
        .imageAssetUploader .preview img {
            height: 3em;
            width: 4em;
            object-fit: cover;
            background: rgba(0,0,0,0.2);
            padding: 0.25em 1em;
        }
        .imageAssetUploader .description {
            flex: 1 1 auto;
            padding: 1em;
            cursor: pointer;
        }

        .imageAssetUploader .description:hover {
            opacity: 0.7;
        }

        .imageAssetUploader .deleter, .logBookPreview .deleter {
            color: red;
            background: rgba(255,0,0,0.1);
            border: none;
            font-size: 1.2em;
            border-radius: 0.3em;
            margin: 0.5em;    
            cursor: pointer;
            padding: 0.1em 0.25em;
        }
        .imageAssetUploader .deleter:hover, .logBookPreview .deleter:hover {
            background: rgba(255,0,0,0.3);    
        }
        .logBookPreview .deleter {
            min-height: initial;
            position: absolute;
            right: 0px;
            margin-top: 0;
        }

        steps textarea, steps input {
            display: block;
            width: 100%;
            border: none;
            background: rgba(255,255,255,0.05);
            color: white;
            padding: 1em;
            box-sizing: border-box;
        } 
    </style>
    <script>
        // Normal mode
        // Switch layout to put mobile controller on the view screen as a sidebar
        window.cotinkerConfig.sidebarController = true;
        window.cotinkerConfig.hideCollabButtons = true;
        window.cotinkerConfig.hideSendNote = false;

        function formatTime(time) {
            let hours = Math.floor(time / 3600);
            let minutes = Math.floor((time - hours * 3600) / 60);
            let seconds = (time - hours * 3600 - minutes * 60).toFixed(0);

            if(hours < 10) {
                hours = "0"+hours;
            }
            if(minutes < 10) {
                minutes = "0"+minutes;
            }
            if(seconds < 10) {
                seconds = "0"+seconds;
            }

            return hours+":"+minutes+":"+seconds;
        }

        function resetCurrentMakeCodeFragment() {
            let ok = confirm("Er du sikker pÃ¥ du vil genskabe den oprindelige kode?");
            if (!ok) {
                return;
            }

            console.log("Resetting makecode...");

            let revision = document.body.getAttribute("data-original-revision");

            console.log("Original revision:", revision);

            if (revision != null && makeController?.currentlyLinkedCodeFragment != null) {
                let currentCodeFragmentId = makeController.currentlyLinkedCodeFragment.html[0].id;

                console.log("Current code fragment id:", currentCodeFragmentId);

                if (currentCodeFragmentId != null) {
                    fetch(location.pathname + revision + "?raw").then((response) => {
                        response.text().then((text) => {
                            let domParser = new DOMParser();

                            let parsedDocument = domParser.parseFromString(text, "text/html");

                            let loadedFragmentHtml = parsedDocument.querySelector("#" + currentCodeFragmentId);

                            if (loadedFragmentHtml != null) {
                                let loadedFragment = Fragment.setupFragment(cQuery(loadedFragmentHtml));

                                if (loadedFragment != null) {
                                    makeController.currentlyLinkedCodeFragment.raw = loadedFragment.raw;
                                }
                            }
                        });
                    });
                }
            }
        }
        window.resetCurrentMakeCodeFragment = resetCurrentMakeCodeFragment;

        function readCSV(csvFile) {
            return new Promise((resolve, reject) => {
                try {
                    fetch(csvFile).then((response) => {
                        response.text().then((csv) => {
                            console.debug("CSV Loaded...");
                            let json = {
                                header: [],
                                data: []
                            };

                            let first = true;

                            csv.split("\n").forEach((line) => {
                                if (line.trim().length === 0) {
                                    return;
                                }

                                let columns = line.split(",");

                                if (first) {
                                    //Read header names
                                    json.header = columns;
                                    first = false;
                                    return;
                                }

                                json.data.push(columns);
                            });

                            resolve(json);
                        });
                    });
                } catch(e) {
                    console.warn("Error during csv read:", e);
                    reject();
                }
            });
        }

        enqueueAfterLoad(async ()=>{
            if (view){
                await WPMv2.require("cotinker-pxt-microbit");
                await WPMv2.require("cotinker-cavi-shared-sensors");

                window.sharedSensor = new CaviSharedSensors();
            } else {
                enableScreenshots();
            }
        });
    </script>
    <slides>
        <slide id="welcome" class="">
            <img style="width: 80%;height: 80%;object-fit: contain;" src="../../../img/logo_light.svg">
        </slide>        
        <slide id="code"> 
            <code-fragment data-type="text/javascript">
                // Insert MakeCode editor in slide regardless of mode
                if (!window.makeController){
                    let slide = document.querySelector("#code");
                    let transient = document.createElement("transient");
                    transient.classList.add("makecode-view");
                    slide.appendChild(transient);
                    let makeController = new MakeController(transient);
                    window.makeController = makeController;
                }
            </code-fragment>        
            
            <code-fragment data-type="text/javascript" data-slide-mode="connect">
                await makeController.linkFragment(Fragment.one("#smiley"), {
                    "blocks": {
                        "pxt-on-start": 1,
                        "device_show_leds": 1
                    },                    
                    "defaultState": 0
                });
                makeController.stopSimulator();
                makeController.hideSimulator();
            </code-fragment>      
            
            <code-fragment data-type="text/javascript" data-slide-mode="tempdisplay">
                await makeController.linkFragment(Fragment.one("#tempdisplay"), {
                    "blocks": {
                        "every_interval": 1,
                        "device_show_number": 1,
                    	"device_temperature": 1
                    },                    
                    "defaultState": 0
                });
                makeController.stopSimulator();
                makeController.hideSimulator();
            </code-fragment>      
            <code-fragment data-type="text/javascript" data-slide-mode="tempstore">
                await makeController.linkFragment(Fragment.one("#tempdisplay"), {
                    "blocks": {
                        "every_interval": 1,
                        "device_show_number": 1,
                    	"device_temperature": 1,
                    	"dataloggerlog": 1
                    },                    
                    "defaultState": 0
                });
                makeController.stopSimulator();
                makeController.hideSimulator();
            </code-fragment>      
            <code-fragment data-type="text/javascript" data-slide-mode="tempmodule">
                await makeController.linkFragment(Fragment.one("#tempdisplay"), {
                    "blocks": {
                        "every_interval": 1,
                        "device_show_number": 1,
                    	"device_temperature": 1,
                    	"dataloggerlog": 1,
                    	"kitronik_klimate_read_temperature": 1
                    },                    
                    "defaultState": 0
                });
                makeController.stopSimulator();
                makeController.hideSimulator();
            </code-fragment>      
            <code-fragment data-type="text/javascript" data-slide-mode="superlogger">
                await makeController.linkFragment(Fragment.one("#superlogger"), {
                    "blocks": {
                    },                    
                    "defaultState": 1
                });
                makeController.stopSimulator();
                makeController.hideSimulator();

                setupResetButton();

                onSlideModeUnloaded(()=>{
                    cQuery(".resetButton").remove();
                });

            </code-fragment>      
            <code-fragment data-type="text/javascript" data-slide-mode="homelogger">
                await makeController.linkFragment(Fragment.one("#homie"), {
                    "blocks": {
                    },                    
                    "defaultState": 1
                });
                makeController.stopSimulator();
                makeController.hideSimulator();
            </code-fragment>      
        </slide>
        <slide id="to-the-mobile-mobile">
            <div class="gettingStarted">
                <img class="mobile-imitator" src="../../../img/mobile.svg">
                <div class="screen-imitator">
                    <img class="screen-icon" src="../../../img/screen.svg">
                    <div id="htmlqrcode" class="qrcode"></div>
                </div>
                <p>Scan QR-koden for at fortsÃ¦tte pÃ¥ mobilen</p>
            </div>            
            <style>
                #to-the-mobile-mobile .gettingStarted {
                    position: relative;
                }
                #to-the-mobile-mobile {
                    padding-top: 3.6rem;
                    box-sizing: border-box;
                }
            </style>
        </slide>
        <slide id="log" class="">
            <span class="material-icons-outlined">edit_note</span>
            <style>
                #log .material-icons-outlined {
                    font-size: 50vh;
                    color: rgba(100, 168, 255, 0.2);      
                    opacity: 0.4;
                }
            </style>
        </slide>        
        <slide id="find-data" class="">
            <span class="material-icons-outlined">download_for_offline</span>
            <style>
                #find-data .material-icons-outlined {
                    font-size: 50vh;
                    color: rgba(100, 168, 255, 0.2);      
                    opacity: 0.4; 
                }
            </style>
        </slide>
        <slide id="graph" class="">
            <code-fragment data-type="application/json" id="gruppensGraf">{}</code-fragment>
            <style>
                #graph .graph, #multigraph .chart {
                    background: rgba(255, 255, 255, 0.67);
                    padding: 1em;
                    border: none;
                    margin: 1em;
                    box-shadow: 0 0 1em rgba(0,0,0,0.4);                    
                    color: black;
                }
                #graph .settings {
                    background: rgba(255,255,255,0.1);
                    padding: 1rem;
                    padding-left: 5rem;
                    position: relative;
                    box-sizing: border-box;     
                    max-width: fit-content;
                    margin-left: auto;
                    margin-right: auto;                    
                }
                #graph .settings .material-icons-outlined {
                    position: absolute;
                    top: 1rem;
                    left: 0.5rem;
                    font-size: 3rem;
                    bottom: 1rem;
                    display: flex;
                    width: 4rem;
                    justify-content: center;
                    align-items: center;
                    opacity: 0.2;                    
                }
                #graph .settings > div:not(:last-child) {
                    margin-bottom: 1em;
                }
                #graph .subsettings {
                    margin-left: 6em;
                }
                #graph .flexlabel {
                    display: flex;
                }
                #graph .flexlabel select {
                    flex: 1 1 auto;
                    margin-left: 1em;
                }                

                #graph .empty-placeholder .material-icons-outlined {
                    font-size: 50vh;
                    color: rgba(100, 168, 255, 0.2);      
                    opacity: 0.4; 
                }                
            </style>
            <div class="viewer" style="display:none">
                <div class="graph"></div>
                <div class="settings">
                    <span class="material-icons-outlined">settings</span>
                    <div><label class="flexlabel">Tids-akse: <select class="time"></select></label>
                        <div class="subsettings">
                            <label>Fra: <input type="time" class="from"></label>
                            <label>Til: <input type="time" class="to"></label>
                        </div>
                    </div>
                    <div><label class="flexlabel">Data-akse: <select class="data"></select></label></div>
                </div>
            </div>
            <div class="empty-placeholder">
                <span class="material-icons-outlined">insights</span>             
            </div>

            <code-fragment data-type="text/javascript">
                if (fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference.alreadyRun = true;

                await wpm.require({"repository": "wpm_js_libs", "package": "uPlot"});
                await wpm.requireExternal("https://cdn.jsdelivr.net/npm/uplot@1.6.22/dist/uPlot.min.css");

                let timeSelect = slideReference.querySelector("select.time");
                let dataSelect = slideReference.querySelector("select.data");
                let filterMin = document.querySelector(".viewer input.from");
                let filterMax = document.querySelector(".viewer input.to");

                timeSelect.addEventListener("input", (evt) => {
                    slideReference.setAttribute("data-timeindex", timeSelect.value, {approved: true});
                    Tagger.tag("changedChartSetting", {"setting": "timeIndex"});
                    updateSharedJson();
                });
                dataSelect.addEventListener("input", () => {
                    slideReference.setAttribute("data-dataindex", dataSelect.value, {approved: true});
                    Tagger.tag("changedChartSetting", {"setting": "dataIndex"});
                    updateSharedJson();
                });

                filterMin.addEventListener("input", () => {
                    slideReference.setAttribute("data-filtermin", filterMin.value, {approved: true});
                    Tagger.tag("changedChartSetting", {"setting": "filterMin"});
                    updateSharedJson();
                });
                filterMax.addEventListener("input", () => {
                    slideReference.setAttribute("data-filtermax", filterMax.value, {approved: true});
                    Tagger.tag("changedChartSetting", {"setting": "filterMax"});
                    updateSharedJson();
                });

                logbookFragment = Fragment.one("#logBook");
                logbookFragment.registerOnFragmentChangedHandler(() => {
                    updateChartSettings();
                });

                let filterObserver = new MutationObserver((mutations) => {
                    let updateTimeSeries = false;
                    mutations.forEach((mutation) => {
                        if (mutation.attributeName === "data-timeindex") {
                            updateTimeSeries = true;
                        }
                    });
                    updateChartSettings(updateTimeSeries);
                });


                filterObserver.observe(slideReference, {
                    attributes: true,
                    attributeFilter: ["data-filtermin", "data-filtermax", "data-timeindex", "data-dataindex", "data-csv"]
                });

                const overlay = document.createElement("div");
                overlay.id = "uPlotOverlay";
                overlay.style.display = "none";
                overlay.style.position = "absolute";
                document.body.appendChild(overlay);

                function updateSharedJson() {
                    let gruppe = document.body.getAttribute("data-group-name");
                    if(gruppe != null) {
                        let json = {
                            gruppe: gruppe,
                            filterMin: slideReference.getAttribute("data-filtermin"),
                            filterMax: slideReference.getAttribute("data-filtermax"),
                            timeIndex: slideReference.getAttribute("data-timeindex"),
                            dataIndex: slideReference.getAttribute("data-dataindex"),
                            csvFile: location.origin+location.pathname+slideReference.getAttribute("data-csv")
                        }
                        window.sharedSensor.publishJson(json, "tempChart", "tempChart");
                    }
                }

                window.updateSharedJson = updateSharedJson;

                function updateChartSettings(resetTimeFilters) {
                    console.groupCollapsed("Updating chart settings:", resetTimeFilters);
                    console.trace();
                    console.groupEnd();

                    let csvFile = document.querySelector("slide#graph").getAttribute("data-csv");

                    if(csvFile == null) {
                        return {};
                    }

                    return readCSV(csvFile).then((json) => {
                        if (json?.data?.length > 0) {
                            while (timeSelect.lastChild != null) {
                                timeSelect.lastChild.remove();
                            }
                            while (dataSelect.lastChild != null) {
                                dataSelect.lastChild.remove();
                            }

                            json.header.forEach((headerName, index) => {
                                let option = document.createElement("option");
                                option.textContent = headerName;
                                option.value = index;

                                let optionClone = option.cloneNode(true);

                                timeSelect.appendChild(option);
                                dataSelect.appendChild(optionClone);
                            });

                            let timeIndex = parseInt(slideReference.getAttribute("data-timeindex"));
                            let dataIndex = parseInt(slideReference.getAttribute("data-dataindex"));

                            if (!isNaN(timeIndex)) {
                                timeSelect.value = timeIndex;
                            } else {
                                timeIndex = 0;
                            }

                            if (!isNaN(dataIndex)) {
                                dataSelect.value = dataIndex;
                            } else {
                                dataIndex = 0;
                            }

                            if (!resetTimeFilters) {
                                if (slideReference.hasAttributes("data-filtermin")) {
                                    filterMin.value = slideReference.getAttribute("data-filtermin");
                                }

                                if (slideReference.hasAttributes("data-filtermax")) {
                                    filterMax.value = slideReference.getAttribute("data-filtermax");
                                }
                            }

                            //Render graph
                            slideReference.querySelector(".viewer").style.display = "";
                            slideReference.querySelector(".empty-placeholder").style.display = "none";

                            let timeValues = [];
                            let valueValues = [];

                            let offset = 0;
                            let lastValue = 0;

                            let timeValuePairs = [];

                            json.data.forEach((column) => {
                                timeValuePairs.push({
                                    time: column[timeIndex],
                                    value: column[dataIndex]
                                });
                            });

                            let timeMin = Infinity;
                            let timeMax = -Infinity;

                            timeValuePairs = timeValuePairs.map(({time, value}) => {
                                let timeSplit = time.split(":");

                                if (timeSplit.length === 3) {
                                    //hh:mm:ss format?
                                    time = parseInt(timeSplit[0]) * 60 * 60 + parseInt(timeSplit[1]) * 60 + parseInt(timeSplit[2]);
                                } else {
                                    //Floating point format?
                                    time = parseFloat(time);
                                }

                                time += offset;

                                if (time < lastValue) {
                                    //New timestamp is in the past?
                                    //Lets assume the time was reset, and use an offset

                                    let additionalOffset = lastValue - offset;

                                    time += additionalOffset;
                                    offset = lastValue;
                                }

                                lastValue = time;

                                timeMin = Math.min(timeMin, time);
                                timeMax = Math.max(timeMax, time);

                                value = parseFloat(value);

                                return {time, value};
                            });

                            if (timeMin != Infinity) {
                                //Set min/max on inputs
                                let timeMinHours = Math.floor(timeMin / 3600);
                                let timeMinMinutes = Math.floor((timeMin - timeMinHours * 3600) / 60) - 1;

                                if (timeMinMinutes < 0) {
                                    timeMinMinutes = 59;
                                    timeMinHours -= 1;
                                    if (timeMinHours < 0) {
                                        timeMinHours = 0
                                        timeMinMinutes = 0;
                                    }
                                }

                                if (timeMinHours < 10) {
                                    timeMinHours = "0" + timeMinHours;
                                }
                                if (timeMinMinutes < 10) {
                                    timeMinMinutes = "0" + timeMinMinutes;
                                }

                                let timeMinString = timeMinHours + ":" + timeMinMinutes;

                                let timeMaxHours = Math.floor(timeMax / 3600);
                                let timeMaxMinutes = Math.floor((timeMax - timeMaxHours * 3600) / 60) + 1;

                                if (timeMaxMinutes == 60) {
                                    timeMaxMinutes = 0;
                                    timeMaxHours += 1;

                                    if (timeMaxHours === 24) {
                                        timeMaxHours = 23;
                                        timeMinMinutes = 59;
                                    }
                                }

                                if (timeMaxHours < 10) {
                                    timeMaxHours = "0" + timeMaxHours;
                                }
                                if (timeMaxMinutes < 10) {
                                    timeMaxMinutes = "0" + timeMaxMinutes;
                                }

                                let timeMaxString = timeMaxHours + ":" + timeMaxMinutes;

                                filterMin.setAttribute("min", timeMinString);
                                filterMin.setAttribute("max", timeMaxString);
                                filterMax.setAttribute("min", timeMinString);
                                filterMax.setAttribute("max", timeMaxString);

                                //Check if we have min/max set, if not, force update
                                if(!slideReference.hasAttribute("data-filtermin") || !slideReference.hasAttribute("data-filtermax")) {
                                    resetTimeFilters = true;
                                }

                                if (resetTimeFilters) {
                                    filterMin.value = timeMinString;
                                    filterMax.value = timeMaxString;
                                    slideReference.setAttribute("data-filtermin", filterMin.value);
                                    slideReference.setAttribute("data-filtermax", filterMax.value);
                                }
                            }

                            let filterTimeMin = filterMin.value;
                            let filterTimeMax = filterMax.value;

                            if (filterTimeMin.length > 0) {
                                let split = filterTimeMin.split(":");
                                filterTimeMin = parseInt(split[0]) * 3600 + parseInt(split[1]) * 60;
                            }

                            if (filterTimeMax.length > 0) {
                                let split = filterTimeMax.split(":");
                                filterTimeMax = parseInt(split[0]) * 3600 + parseInt(split[1]) * 60;
                            }

                            timeValuePairs = timeValuePairs.filter(({time, value}) => {
                                let allow = true;
                                if (typeof filterTimeMin === "number") {
                                    if (time < filterTimeMin) {
                                        allow = false;
                                    }
                                }
                                if (typeof filterTimeMax === "number") {
                                    if (time > filterTimeMax) {
                                        allow = false;
                                    }
                                }
                                return allow;
                            });

                            timeValuePairs.forEach(({time, value}) => {
                                timeValues.push(time);
                                valueValues.push(value);
                            });

                            let data = [];
                            data.push(timeValues);
                            data.push(valueValues);

                            drawChart(data, {x: json.header[timeIndex], y: json.header[dataIndex]});
                        } else {
                            slideReference.querySelector(".viewer").style.display = "none";
                            slideReference.querySelector(".empty-placeholder").style.display = "block";
                        }
                    });

                }

                function drawChart(data, headers) {
                    console.debug("Drawing chart:", data);

                    let graph = slideReference.querySelector(".viewer .graph");
                    while (graph.lastChild != null) {
                        graph.lastChild.remove();
                    }

                    overlay.style.display = "none";
                    let logbookEntries = [];

                    function drawLogbook(u, si) {
                        logbookFragment.require().then((logbook) => {
                            let ctx = u.ctx;

                            logbookEntries = [];

                            logbook.forEach((entry) => {
                                let d = new Date(entry.timestamp);
                                let seconds = d.getSeconds() + d.getMinutes() * 60 + d.getHours() * 3600;

                                let x = u.valToPos(seconds, "x", true);
                                let y0 = u.valToPos(u.scales.y.min, "y", true);
                                let y1 = u.valToPos(u.scales.y.max, "y", true);

                                let idx = u.valToIdx(seconds);

                                let yPoint = u.valToPos(u.data[1][idx], "y", true);

                                let xCss = u.valToPos(seconds, "x", false);
                                let yCss = u.valToPos(u.data[1][idx], "y", false);

                                ctx.beginPath();
                                ctx.strokeStyle = "green";
                                ctx.setLineDash([2, 2]);
                                ctx.moveTo(x, y0);
                                ctx.lineTo(x, yPoint);
                                ctx.stroke();

                                ctx.beginPath();
                                ctx.fillStyle = "lime";
                                ctx.arc(x, yPoint, 5, 0, 2 * Math.PI);
                                ctx.fill();

                                logbookEntries.push({x: xCss, y: yCss, event: entry.event, time: seconds});
                            });
                        });
                    }

                    //Add 5 degree trendline
                    let trendlineIndex = data.length;
                    data.push([]);
                    for(let i = 0; i<data[0].length; i++) {
                        if(i === 0 || i === data[0].length-1) {
                            data[trendlineIndex][i] = 5;
                        } else {
                            data[trendlineIndex][i] = null;
                        }
                    }

                    let bounds = null;
                    let animFrame = null;

                    let opts = {
                        title: "Temperatur",
                        id: "chart1",
                        class: "my-chart",
                        width: 800,
                        height: 500,
                        scales: {
                            x: {
                                time: false
                            },
                            y: {
                                range(u, dataMin, dataMax) {
                                    if (dataMin == null)
                                        return [0, 100];
                                    return uPlot.rangeNum(dataMin, dataMax, 0.1, true);
                                }
                            },
                        },
                        hooks: {
                            drawSeries: [
                                (u, si) => {
                                    drawLogbook(u, si);
                                }
                            ],
                            setCursor: [(u) => {
                                const {left, top, idx} = u.cursor;

                                if (animFrame != null) {
                                    cancelAnimationFrame(animFrame);
                                }

                                animFrame = requestAnimationFrame(() => {
                                    animFrame = null;
                                    if (left < 0) {
                                        overlay.style.display = "none";
                                        return;
                                    }

                                    let closestIdx = -1;
                                    let closestDistance = Infinity;

                                    let closeEntries = logbookEntries.filter((entry) => {
                                        let distance = Math.sqrt(Math.pow(entry.x - left, 2) + Math.pow(entry.y - top, 2));
                                        return distance <= 5;
                                    });

                                    while (overlay.lastChild != null) {
                                        overlay.lastChild.remove();
                                    }

                                    if (closeEntries.length > 0) {
                                        if (bounds == null) {
                                            bounds = u.over.getBoundingClientRect();
                                        }

                                        closeEntries.forEach((entry) => {
                                            let div = document.createElement("div");
                                            div.classList.add("entry");
                                            div.textContent = formatTime(entry.time) + " - " + entry.event;
                                            overlay.appendChild(div);
                                        });

                                        overlay.style.display = "block";
                                        overlay.style.top = (top + bounds.top) + "px";
                                        overlay.style.left = (left + bounds.left) + "px";
                                    } else {
                                        overlay.style.display = "none";
                                    }
                                });
                            }]
                        },
                        series: [
                            {
                                label: headers.x,
                                value: (self, rawValue) => formatTime(rawValue)
                            },
                            {
                                // initial toggled state (optional)
                                show: true,

                                spanGaps: false,

                                // in-legend display
                                label: headers.y,
                                value: (self, rawValue) => rawValue,

                                // series style
                                stroke: "red",
                                width: 1,
                                fill: "rgba(255, 0, 0, 0.3)"
                            },
                            {
                                // initial toggled state (optional)
                                show: true,

                                spanGaps: true,

                                // in-legend display
                                label: "Anbefalet temperatur",
                                value: (self, rawValue) => 5,

                                // series style
                                stroke: "blue",
                                width: 1,
                                dash: [10, 5],
                            }
                        ],
                        axes: [
                            {
                                values: (self, ticks, space) => {
                                    return ticks.map((tick) => {
                                        return formatTime(tick);
                                    });
                                }
                            },
                            {}
                        ]
                    };

                    let plot = new uPlot(opts, data, graph);
                }

                updateChartSettings();
            </code-fragment>
        </slide>        
        <slide id="multigraph" class="">
            <div class="chart"></div>
            
            <code-fragment data-type="text/javascript">
                if (fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference.alreadyRun = true;

                await wpm.require({"repository": "wpm_js_libs", "package": "uPlot"});
                await wpm.requireExternal("https://cdn.jsdelivr.net/npm/uplot@1.6.22/dist/uPlot.min.css");

                await window.sharedSensor.waitForConnect();

                window.sharedSensor.registerJsonChangeListener("tempChart", async () => {
                    updateChart();
                });

                let chart = slideReference.querySelector(".chart");

                let colors = ["red", "yellow", "green", "lime", "pink", "orange", "silver", "white", "purple"];

                async function updateChart() {
                    let json = await window.sharedSensor.getJson("tempChart");

                    let data = [];
                    //Add x values array
                    data.push([]);

                    let opts = {
                        title: "Temperaturer",
                        id: "chart2",
                        class: "my-chart",
                        width: 800,
                        height: 600,
                        scales: {
                            x: {
                                time: false
                            },
                            y: {
                                range(u, dataMin, dataMax) {
                                    if (dataMin == null)
                                        return [0, 100];
                                    return uPlot.rangeNum(dataMin, dataMax, 0.1, true);
                                }
                            }
                        },
                        series: [
                            {
                                label: "Time",
                                value: (self, rawValue) => formatTime(rawValue)
                            }
                        ],
                        axes: [
                            {
                                values: (self, ticks, space) => {
                                    return ticks.map((tick) => {
                                        return formatTime(tick);
                                    });
                                }
                            },
                            {}
                        ]
                    };

                    let dataMap = new Map();

                    for(let series of json) {
                        let seriesOpts = {
                            // initial toggled state (optional)
                            show: true,

                            spanGaps: false,

                            // in-legend display
                            label: series.gruppe,
                            value: (self, rawValue) => rawValue,

                            // series style
                            width: 1,
                        };

                        let seriesIndex = opts.series.push(seriesOpts) - 1;
                        seriesOpts.stroke = colors[seriesIndex-1];

                        let offset = 0;
                        let lastValue = -1;

                        let filterMin = -Infinity;
                        let filterMax = Infinity;

                        let filterMinSplit = series.filterMin.split(":");
                        if (filterMinSplit.length == 2) {
                            //hh:mm format?
                            filterMin = parseInt(filterMinSplit[0]) * 60 * 60 + parseInt(filterMinSplit[1]) * 60;
                        }

                        let filterMaxSplit = series.filterMax.split(":");
                        if (filterMaxSplit.length == 2) {
                            //hh:mm format?
                            filterMax = parseInt(filterMaxSplit[0]) * 60 * 60 + parseInt(filterMaxSplit[1]) * 60;
                        }


                        let seriesData = (await readCSV(series.csvFile)).data.map((entry)=>{
                            let time = entry[series.timeIndex];
                            let value = entry[series.dataIndex];

                            let timeSplit = time.split(":");

                            if (timeSplit.length === 3) {
                                //hh:mm:ss format?
                                time = parseInt(timeSplit[0]) * 60 * 60 + parseInt(timeSplit[1]) * 60 + parseInt(timeSplit[2]);
                            } else {
                                //Floating point format?
                                time = parseFloat(time);
                            }

                            time += offset;

                            if (time < lastValue) {
                                //New timestamp is in the past?
                                //Lets assume the time was reset, and use an offset

                                let additionalOffset = lastValue - offset;

                                time += additionalOffset;
                                offset = lastValue;
                            }

                            lastValue = time;

                            value = parseFloat(value);

                            return {time, value};
                        });

                        seriesData = seriesData.filter(({time, value}) => {
                            let allow = true;
                            if (time < filterMin) {
                                allow = false;
                            }
                            if (time > filterMax) {
                                allow = false;
                            }
                            return allow;
                        });

                        //Push series data array
                        data.push([]);

                        seriesData.forEach(({time, value}) => {
                            let timeEntries = dataMap.get(time);
                            if (timeEntries == null) {
                                timeEntries = {};
                                dataMap.set(time, timeEntries);
                            }
                            timeEntries[seriesIndex] = value;
                        });
                    }

                    let sortedKeys = Array.from(dataMap.keys()).sort((s1, s2)=>{
                        return s1 - s2;
                    });

                    sortedKeys.forEach((time) =>{
                        let timeEntries = dataMap.get(time);

                        data[0].push(time);

                        for(let i = 1; i<data.length; i++) {
                            if(timeEntries[i] != null) {
                                data[i].push(timeEntries[i]);
                            } else {
                                data[i].push(null);
                            }
                        }
                    });


                    //Add 5 degree trendline
                    let trendlineIndex = data.length;
                    data.push([]);
                    for(let i = 0; i<data[0].length; i++) {
                        if(i === 0 || i === data[0].length-1) {
                            data[trendlineIndex][i] = 5;
                        } else {
                            data[trendlineIndex][i] = null;
                        }
                    }

                    opts.series.push({
                        // initial toggled state (optional)
                        show: true,

                        spanGaps: true,

                        // in-legend display
                        label: "Anbefalet temperatur",
                        value: (self, rawValue) => 5,

                        // series style
                        stroke: "blue",
                        width: 1,
                        dash: [10, 5],
                    });

                    drawChart(opts, data, chart);
                }

                let animationId = null;

                function drawChart(opts, data, chart) {
                    if(animationId != null) {
                        cancelAnimationFrame(animationId);
                    }
                    requestAnimationFrame(()=>{
                        animationId = null;
                        while(chart.lastChild != null) {
                        chart.lastChild.remove();
                        }

                        let plot = new uPlot(opts, data, chart);
                    });
                }

                updateChart();
            </code-fragment>
        </slide>    
        <slide id="home">
            <span class="material-icons-outlined">kitchen</span>
            <style>
                #home .material-icons-outlined {
                    font-size: 50vh;
                    color: rgba(100, 168, 255, 0.2);      
                    opacity: 0.8;
                    position: relative;
                }
                @keyframes supersizeAppears {
                    0% {transform: scale(0.5); opacity: 0;}
                    90% {transform: scale(1.1)}
                    100% {}
                }
                @keyframes supersizeGlow {
                    from {text-shadow: 0 0 0.1em rgba(255,255,255,0.2);}
                    to {text-shadow: 0 0 0.2em white;}
                }
                
                #home span:after {
                    content: "â";
                    color: greenyellow;
                    position: absolute;
                    top: 50%;
                    left: 60%;
                    font-size: 0.5em;
                    animation: supersizeAppears 0.25s ease-out, supersizeGlow 2s alternate ease-in-out infinite;
                }
                
            </style>     
        </slide>
    </slides>
    
    <steps>
        <step  name="Welcome" data-slide="welcome" >
            <code-fragment data-type="text/markdown" auto="true">
# Reducer Madspild!

Velkommen til dette forlÃ¸b omkring madspild!

En af grundene til at mad bliver smidt ud i stedet for at blive spist er at det nÃ¥r at blive dÃ¥rligt, fÃ¸r vi fÃ¥r det spist. Ofte er det pÃ¥ grund af at maden bliver opbevaret ved en forkert temperatur uden at vi lÃ¦gger mÃ¦rke til det.

I dette forlÃ¸b skal vi prÃ¸ve at blive klogere pÃ¥ hvordan vi opbevarer fÃ¸devarer her pÃ¥ skolen og derhjemme ved at instrumentere vores kÃ¸leskabe med sensorer for at se, om de opfylder FÃ¸devarestyrelsens kÃ¸lekrav til fÃ¸devarer.

NÃ¥r i skal svare pÃ¥ opgaverne under forlÃ¸bet, kan i bruge "Send Note" feltet herunder, der kan man ogsÃ¥ uploade billeder.

Da forlÃ¸bet bruger en micro:bit, og skal snakke med den fra browseren, er det vigtigt et i bruger en chromium baseret browser, som fx Chrome eller Microsoft Edge.

NÃ¥r alle i gruppen er klar til at gÃ¥ i gang, sÃ¥ scroll ned til navigationen her i bunden og tryk pÃ¥ Next-knappen.                
            </code-fragment>
        </step>        
        <step name="Connect" data-slide="code" data-slide-mode="connect">
            <code-fragment data-type="text/markdown" auto="true">
# Vi er alle blinde

FÃ¸r vi overhovedet kan vurdere om vi overholder kravene for opbevaring af fÃ¸devarer, har vi brug for at vide hvad temperaturen i kÃ¸leskabene er. DesvÃ¦rre viser mange kÃ¸leskabe kun den temperatur, de er indstillet til (hvis de overhovedet viser noget) og ikke den faktiske temperatur i kÃ¸leskabet - og der er muligvis ogsÃ¥ forskel pÃ¥ temperaturen forskellige steder i kÃ¸leskabet.

Vi bliver nÃ¸dt til at bygge en mÃ¥ler, sÃ¥ vi kan se hvad temperaturen rent faktisk er. Til det kan vi bruge en Micro:bit.Â 

PÃ¥ computeren er et MakeCode-projekt til Micro:bit, som tegner en smiley, nÃ¥r programmet udfÃ¸res. For at se om Micro:bitâen overhovedet fungerer, kan vi prÃ¸ve at lÃ¦gge programmet over pÃ¥ den

* Forbind fÃ¸rst Micro:bitâen til computeren med USB-kablet uden at andre moduler eller batteri-pakker sat til den
* Tryk pÃ¥ knappen ââ¦â ved siden af âDownloadâ og vÃ¦lg âConnect Deviceâ/âForbind enhedâ i popuppen
* Nu kan man trykke pÃ¥ âDownloadâ for at sende programmet og starte det
* PrÃ¸v at rette i smileyâen og tryk pÃ¥ Download-knappen for at sende programmet igen. Hvad skete der pÃ¥ computerne, da i hver isÃ¦r begyndte at rette i programmet? Kan I fÃ¥ alle gruppens Micro:bits til at vise den samme smiley?
            </code-fragment>            
 
            <code-fragment id="smiley" data-type="application/json" data-restrict="smiley">{
                "header": {
                "name": "Untitled",
                "meta": {"caviId": "smiley"},
                "editor": "blocksprj",
                "pubId": "",
                "pubCurrent": false,
                "target": "microbit",
                "targetVersion": "5.0.15",
                "id": "1ed57c42-b020-4697-7678-c125652f36c2",
                "recentUse": 1669891147,
                "modificationTime": 1669891147,
                "path": "Untitled-2",
                "cloudCurrent": false,
                "saveId": null,
                "githubCurrent": false
                },
                "text": {
                "README.md": "",
                "main.blocks": "<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"pxt-on-start\" x=\"23\" y=\"21\"><statement name=\"HANDLER\"><block type=\"device_show_leds\"><field name=\"LEDS\">`\n        . # . # . \n        . # . # . \n        . . . . . \n        # . . . # \n        . # # # .\n        `</field></block></statement></block></xml>",
                "main.ts": "basic.showLeds(`\n    . # . # .\n    . # . # .\n    . . . . .\n    # . . . #\n    . # # # .\n    `)\n",
                "pxt.json": "{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"
                }
                }</code-fragment>
        </step>            
        <step name="Termometer" data-slide="code" data-slide-mode="tempdisplay">    
            <code-fragment data-type="text/markdown" auto="true">
# Byg et Termometer

Nu er der Ã¥bnet op for nogle andre af blokkene i MakeCode - blandt andet en blok, som viser et tal pÃ¥ displayet, en blok som udfÃ¸rer noget kode med et fast interval, og en rund blok som mÃ¥ler temperaturen inde i Micro:bitâens microchip.

* Kan I sammen bygge et program, som en gang i sekundet viser hvad temperaturen i chippen er lige nu, ved at skrive det som et tal pÃ¥ displayet?
* Hvis I sender programmet til alle Micro:bits i gruppen, er de sÃ¥ enige om temperaturen?
* Virker mÃ¥lingerne realistiske eller prÃ¦cise?
* Kan I med vilje pÃ¥virke mÃ¥lingerne, sÃ¥ temperaturen bliver hÃ¸jere eller lavere?              
            </code-fragment>                 
            <code-fragment id="tempdisplay" data-type="application/json" data-restrict="tempdisplay">
{
    "header": {
        "name": "Untitled",
        "meta": {"caviId": "tempdisplay"},
        "editor": "blocksprj",
        "pubId": "",
        "pubCurrent": false,
        "target": "microbit",
        "targetVersion": "5.0.15",
        "id": "1a8b737b-a66d-4a29-abb3-0bab6b855e9b",
        "recentUse": 1669637556,
        "modificationTime": 1669637556,
        "path": "Untitled-35",
        "cloudCurrent": false,
        "saveId": null,
        "githubCurrent": false
    },
    "text": {
        "README.md": "",
        "main.blocks": "<xml xmlns=\"https://developers.google.com/blockly/xml\"></xml>",
        "main.ts": "\n",
        "pxt.json": "{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-kitronik-klimate\": \"github:kitronikltd/pxt-kitronik-klimate#v1.0.2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\",\n    \"languageRestriction\": \"blocks-only\"\n}\n"
    }
}
            </code-fragment> 
        </step> 
        <step name="Indsamling" data-slide="code" data-slide-mode="tempstore">    
            <code-fragment data-type="text/markdown" auto="true">
# Dataopsamling

Hvis vi skal overvÃ¥ge et kÃ¸leskab over lang tid, kan det godt vÃ¦re lidt trÃ¦ls at skulle stÃ¥ og kigge pÃ¥ displayet pÃ¥ Micro:bitâen hele tiden for at aflÃ¦se temperaturen.

I stedet kan vi bruge den indbyggede lagerplads til at gemme mÃ¥lingerne, sÃ¥ vi kan se dem senere.

* Udvid termometer-programmet, som I har lavet, sÃ¥ det ud over at vise temperaturen ogsÃ¥ logger temperaturen til en kolonne navngivet âtempâ
* Send det nye program til Micro:bitâen

Nu gemmes temperaturdata i en fil pÃ¥ Micro:bitâen. SÃ¥ lÃ¦nge den sidder til med USB-kablet kan filen Ã¥bnes ved at bruge en fil-browser til at Ã¥bne filen MY_DATA.HTM i roden af âMICROBITâ drevet.

* Ãbn MY_DATA.HTM og se hvad der er gemt. Stemmer det overens med forventningerne?
* Hvad sker der, hvis man slukker Micro:bitâen ved at tage den ud af USB og derefter tÃ¦nder den igen ved at sÃ¦tte den til igen? Hvordan pÃ¥virker det de gamle data - og de nye?
* PrÃ¸v at trykke pÃ¥ âDownloadâ-knappen i MY_DATA.HTM og se pÃ¥ indholdet af CSV-filen som den henter. Giver det mening?
* Hvordan sletter eller nulstiller man dataopsamlingen, sÃ¥ man kan starte forfra pÃ¥ en frisk?
* Hent CSV-filen igen for at bekrÃ¦fte at den er tom
            </code-fragment>                 
        </step>
        <step name="Klimamodul" data-slide="code" data-slide-mode="tempmodule"> 
            <code-fragment data-type="text/markdown" auto="true">
# Klimamodul

Vi kan gÃ¸re mÃ¥lingerne mere prÃ¦cise ved at bruge et klima-modul i stedet for den lidt unÃ¸jagtige indbyggede temperatursensor i Micro:bitâens microchip. Klima-modulerne er til gengÃ¦ld noget dyrere, sÃ¥ hver gruppe mÃ¥ nÃ¸jes med et enkelt klima-modul til deling.

* Byg en udvidet mÃ¥ler ved at sÃ¦tte en af gruppens Micro:bits sammen med klima-modulet
* Opgrader i fÃ¦llesskab jeres termometer-program, sÃ¥ det nu bÃ¥de viser og logger den nye, mere nÃ¸jagtige, temperatur-blok fra âKitronik Klimateâ-sektionen i stedet for den indbyggede temperaturmÃ¥ler
* PrÃ¸v programmet pÃ¥ Micro:bitâen med klima-modulet. Virker det som forventet og kan man hente gemte data ud af det?                
            </code-fragment>                 
        </step>
        <step name="Instrumentation" data-slide="code" data-slide-mode="superlogger">    
            <code-fragment data-type="text/markdown" auto="true">
# MÃ¥ler til et KÃ¸leskab

Her er et program, som bygger videre pÃ¥ termometeret fra fÃ¸r, men der er nogle nye funktioner:Â 
1. Nu kan man nulstille dataloggen ved at holde bÃ¥de knap A og knap B pÃ¥ forsiden af Micro:bitâen nede pÃ¥ samme tid
2. Displayet er slukket og viser ikke lÃ¦ngere temperaturen for at spare pÃ¥ strÃ¸mmen
3. Den bruger nu uret i klima-modulet til at logge hvad klokken var hver gang

Vi skal have gjort kÃ¸leskabs-mÃ¥leren klar:

* Kig pÃ¥ programmet og se om det giver mening
* PrÃ¸v at lÃ¦gge programmet op pÃ¥ gruppens Micro:bit med klima-modul
* Tag Micro:bitâen ud af computeren og sÃ¦t batteri-pakken til i stedet (nogle batteri-pakker har ogsÃ¥ en lille kontakt der skal tÃ¦ndes)
* Giv jeres mÃ¥ler et navn. Skriv det pÃ¥ et lille stykke papir og tape det fast pÃ¥ den, sÃ¥ I kan kende den igen

Hvis i kommer til at Ã¸delÃ¦gge koden, sÃ¥ den ikke virker korrekt mere, kan i trykke <a class="codeResetButton" href="#">her</a> for at genskabe den oprindelige kode.
            </code-fragment>
            <code-fragment data-type="text/javascript">
                if(fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference. alreadyRun = true;

                stepReference.querySelector(".codeResetButton").addEventListener("click", ()=>{
                    runOnScreen("resetCurrentMakeCodeFragment");
                });
            </code-fragment>
            <code-fragment id="superlogger" data-type="application/json" data-restrict="superlogger">
{
    "header": {
        "name": "Ikke-navngivet",
        "meta": {
            "caviId": "superlogger"
        },
        "editor": "blocksprj",
        "pubId": "",
        "pubCurrent": false,
        "target": "microbit",
        "targetVersion": "5.0.15",
        "id": "80349577-4f28-474e-38b9-d609c634df33",
        "recentUse": 1669637672,
        "modificationTime": 1669637672,
        "path": "Ikke-navngivet",
        "cloudCurrent": false,
        "saveId": null,
        "githubCurrent": false
    },
    "text": {
        "README.md": "",
        "main.blocks": "<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"every_interval\" x=\"0\" y=\"0\"><value name=\"interval\"><shadow type=\"longTimePicker\"><field name=\"ms\">1000</field></shadow></value><statement name=\"HANDLER\"><block type=\"dataloggerlog\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"1\" _input_init=\"true\"></mutation><value name=\"data1\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"time\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"kitronik_rtc_read_time\"></block></value></shadow></value><value name=\"data2\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"temp\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"kitronik_klimate_read_temperature\"><field name=\"temperature_unit\">Kitronik_klimate.TemperatureUnitList.C</field></block></value></shadow></value><value name=\"data3\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data4\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data5\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data6\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data7\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data8\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data9\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data10\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value></block></statement></block><block type=\"device_button_event\" x=\"530\" y=\"-5\"><field name=\"NAME\">Button.AB</field><statement name=\"HANDLER\"><block type=\"dataloggerdeletelog\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"deleteType\">datalogger.DeleteType.Fast</field><next><block type=\"basic_show_icon\"><field name=\"i\">IconNames.Yes</field><next><block type=\"device_clear_display\"><next><block type=\"control_reset\"></block></next></block></next></block></next></block></statement></block></xml>",
        "main.ts": "input.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.Yes)\n    basic.clearScreen()\n    control.reset()\n})\nloops.everyInterval(1000, function () {\n    datalogger.log(\n    datalogger.createCV(\"time\", kitronik_RTC.readTime()),\n    datalogger.createCV(\"temp\", Kitronik_klimate.temperature(Kitronik_klimate.TemperatureUnitList.C))\n    )\n})\n",
        "pxt.json": "{\n    \"name\": \"Ikke-navngivet\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-kitronik-klimate\": \"github:kitronikltd/pxt-kitronik-klimate#v1.0.2\",\n        \"pxt-kitronik-rtc\": \"github:kitronikltd/pxt-kitronik-rtc#v1.0.2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\",\n    \"yotta\": {\n        \"config\": {\n            \"microbit-dal\": {\n                \"bluetooth\": {\n                    \"open\": 1,\n                    \"whitelist\": 0,\n                    \"security_level\": null\n                }\n            }\n        }\n    }\n}\n",
        ".simstate.json": "{}"
    }
}
	    </code-fragment>
        </step>
        <step name="Logbook" data-slide="to-the-mobile-mobile">
            <code-fragment data-type="text/markdown" auto="true">
# Dataopsamling

Nu er vi klar til at gÃ¥ felten! Til det skal vi bruge et kÃ¸leskab, mÃ¥leren som I har bygget, og en mobil udgave af CoTinker. CoTinker hjÃ¦lper med at indsamle andre data og observationer end dem som mÃ¥leren kan mÃ¥le direkte.

Det nÃ¦ste stykke tid skal vi overvÃ¥ge og observere kÃ¸leskabet og tage en note hver gang der sker noget spÃ¦ndende med det - f.eks. hvis nogen Ã¥bner kÃ¸leskabet, sÃ¦tter noget ind eller tager noget ud af det.
HjÃ¦lp hinanden i gruppen med at skrive noterne, hvis der sker mange ting samtidigt. 

Hvis kÃ¸leskabet slet ikke bliver Ã¥bnet i lÃ¸bet af forsÃ¸get, sÃ¥ prÃ¸v selv at Ã¥bne det i 20-30 sekunder og luk det igen.

* Scan QR-koden med jeres mobiltelefoner for at Ã¥bne den mobile udgave af opgave-vejledningen i CoTinker pÃ¥ mobilen. 

Vent med at trykke pÃ¥ "Next" indtil alle i gruppen har fÃ¥et scannet koden og er klar
            </code-fragment>
        </step>        
        
        <!-- This part takes place on the mobile phone -->
        <step name="LogbookPlace" data-slide="log">
            <code-fragment data-type="text/markdown" auto="true">
# Placering af MÃ¥ler

Det er vigtigt at vÃ¦lge en god placering til dataopsamling - og at dokumentere det valg man trÃ¦ffer. PÃ¥ denne mÃ¥de kan man senere se om der har vÃ¦ret specielle forhold, der har gjort sig gÃ¦ldende, hvis Ã©n mÃ¥ler pÃ¥ et senere tidspunkt viser sig at have mÃ¥lt helt anderledes end alle andre mÃ¥lere.

* Find det kÃ¸leskab I vil mÃ¥le pÃ¥ og vÃ¦lg et interessant sted - gerne et andet sted end der, hvor de andre grupper har deres mÃ¥ler
* LÃ¦g mÃ¥leren i kÃ¸leskabet og tryk pÃ¥ A+B pÃ¥ forsiden af Micro:bitâen for at nulstille og starte mÃ¥lingen
* Tryk her pÃ¥ <button class="upload">&#128247; Upload</button> for at uploade et nÃ¦rbillede af placeringen inde i kÃ¸leskabet som fotodokumentation
* Tryk evt. igen for at uploade et billede af kÃ¸leskabet hvor I pÃ¥ lidt lÃ¦ngere afstand peger pÃ¥ hvilket kÃ¸leskab det er og hvor det er i kÃ¸leskabet
* Skriv i fÃ¦llesskab detaljer omkring mÃ¥lingerne sÃ¥ i kan huske det senere.

NÃ¥r i har placeret jeres mÃ¥ler, tryk da pÃ¥ "NÃ¦ste".
            </code-fragment>
            <code-fragment data-type="text/javascript">
                if(fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference. alreadyRun = true;

                let uploadButton = fragmentSelfReference.html[0].closest("step").querySelector(".upload");

                function handleUploadClicked() {
                    uploadImage().then((result) => {
                        let img = new Image();
                        img.addEventListener("load", ()=>{
                            Steps.instance.postScreenshot(location.pathname + result.full, location.pathname + result.thumb, img.width, img.height);
                        });

                        img.src = location.pathname + result.full;

                        Tagger.tag("uploadImage");
                    });
                }

                uploadButton.addEventListener("click", handleUploadClicked);
            </code-fragment>
        </step>
        <step name="LogbookButtons" data-slide="log">
            <code-fragment data-type="application/json" id="logBook">[
            ]</code-fragment>
            <template id="otherLogEntryTpl">
                <div class="logbookEntryEditor">
                    <label>Hvad skete der? <input class="eventmsg" placeholder="Beskriv hÃ¦ndelsen"/></label>
                    <div class="buttons">
                        <button class="cancel">Fortryd</button> <button class="add">TilfÃ¸j</button>
                    </div>
                </div>
            </template>
            <style>
                step[name="LogbookButtons"] ul {
                    display: flex;
                    list-style: none;
                    margin-left: 1em;      
                    padding: 0;
                }
                step[name="LogbookButtons"] ul li {
                    padding: 1em;
                }
                step[name="LogbookButtons"] ul li button {
                    padding: 1em;
                    min-height: 6em;
                }
                .logbookEntryEditor {
                    padding: 1em;
                }
                .logbookEntryEditor label {
                    display: flex;
                    flex-direction: column;
                }
                .logbookEntryEditor .buttons {
                    text-align: right;
                    margin-top: 1em;
                }
                .logbookEntryEditor .buttons button {
                    padding: 1em;
                    margin-left: 1em;
                }         
                step[name="LogbookButtons"] .logBookPreview {
                    display: block;
                    margin: 0;
                    padding: 0;
                }
                step[name="LogbookButtons"] .logBookPreview li {
                    padding: 0.25em 1em;                    
                }                
                .logBookPreview .event {
                    margin-left: 1em;
                    position: relative;
                }
                .logBookPreview .date {
                    font-size: 0.8em;
                    font-weight: bold;
                    opacity: 0.5;
                }
            </style>
            <code-fragment data-type="text/markdown" auto="true">
# Logbog

Tryk pÃ¥ knapperne prÃ¦cis nÃ¥r der sker noget spÃ¦ndende for at tilfÃ¸je et punkt til logbogen:

* <button class="openDoor">DÃ¸ren Ã¥bnes</button>
* <button class="closeDoor">DÃ¸ren lukkes</button>
* <button class="other">Andet...</button>

<div class="otherContainer"></div>
<ul class="logBookPreview"></ul>

Tryk pÃ¥ "Next" nedenfor nÃ¥r forsÃ¸get skal til at afsluttes
            </code-fragment>

            <code-fragment data-type="text/javascript">
                if (fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference.alreadyRun = true;

                class LogBook {
                    constructor() {
                        this.fragment = Fragment.one("#logBook");
                    }

                    async addEntry(event, timestamp = null) {
                        if (timestamp == null) {
                            timestamp = Date.now();
                        }
                        let entry = {
                            timestamp,
                            event
                        };

                        let json = [];

                        try {
                            json = await this.fragment.require();
                        } catch (e) {
                            console.warn("Error reading logbook json:", e);
                        }

                        json.push(entry);

                        Tagger.tag("logbookAddEntry", {"logbookEvent": event});

                        this.fragment.raw = JSON.stringify(json, null, 2);
                    }

                    async deleteEntry(entry) {
                        let json = await this.fragment.require();

                        json.splice(json.indexOf(entry), 1);

                        Tagger.tag("logbookDeleteEntry", {"logbookEvent": entry.event});

                        this.fragment.raw = JSON.stringify(json, null, 2);
                    }
                }

                const logbook = new LogBook();

                const step = fragmentSelfReference.html[0].closest("step");

                const otherContainer = step.querySelector("div.otherContainer");

                step.querySelector("button.openDoor").addEventListener("click", () => {
                    logbook.addEntry("KÃ¸leskab Ã¥bnet");
                });
                step.querySelector("button.closeDoor").addEventListener("click", () => {
                    logbook.addEntry("KÃ¸leskab lukket");
                });
                step.querySelector("button.other").addEventListener("click", () => {
                    let timestamp = Date.now();
                    let tpl = WebstrateComponents.Tools.loadTemplate("#otherLogEntryTpl");
                    let transient = document.createElement("transient");
                    transient.appendChild(tpl);

                    while (otherContainer.lastChild != null) {
                        otherContainer.lastChild.remove();
                    }

                    function addEntry() {
                        let msg = tpl.querySelector(".eventmsg").value.trim();

                        if (msg.length > 0) {
                            logbook.addEntry(msg, timestamp);
                        }
                        transient.remove();
                    }

                    tpl.querySelector(".eventmsg").addEventListener("keyup", (evt) => {
                        if (evt.keyCode === 13) {
                            addEntry();
                        }
                    });

                    tpl.querySelector(".add").addEventListener("click", () => {
                        addEntry();
                    });
                    tpl.querySelector(".cancel").addEventListener("click", () => {
                        transient.remove();
                    });

                    otherContainer.appendChild(transient);

                    tpl.querySelector(".eventmsg").focus();
                });

                const logBookPreview = step.querySelector(".logBookPreview");

                function formatDate(date) {
                    var hours = date.getHours();
                    var minutes = date.getMinutes();
                    minutes = minutes < 10 ? '0' + minutes : minutes;
                    var strTime = hours + ':' + minutes;
                    return (date.getMonth() + 1) + "/" + date.getDate() + "/" + date.getFullYear() + "  " + strTime;
                }

                function updateLogBookPreview() {
                    logbook.fragment.require().then((json) => {
                        while (logBookPreview.lastChild != null) {
                            logBookPreview.lastChild.remove();
                        }

                        json.reverse().forEach((entry) => {
                            let li = document.createElement("li");
                            li.classList.add("entry");

                            let date = new Date(entry.timestamp);
                            let dateDiv = document.createElement("div");
                            dateDiv.classList.add("date");
                            dateDiv.textContent = formatDate(date);
                            li.appendChild(dateDiv);

                            let eventDiv = document.createElement("div");
                            eventDiv.classList.add("event");
                            eventDiv.textContent = escapeHTML(entry.event);
                            li.appendChild(eventDiv);

                            let deleter = document.createElement("button");
                            deleter.classList.add("deleter");
                            deleter.innerText = "X";
                            eventDiv.appendChild(deleter);
                            deleter.addEventListener("click", async () => {
                                let answer = confirm("Er du sikker pÃ¥ du vil slette logbog indgangen ["+entry.event+"]");

                                if (answer === true) {
                                    await logbook.deleteEntry(entry);
                                }
                            });

                            logBookPreview.appendChild(li);
                        });
                    });
                }

                logbook.fragment.registerOnFragmentChangedHandler(() => {
                    updateLogBookPreview();
                });

                updateLogBookPreview();
            </code-fragment>
        </step>
        <step name="LogbookEnding" data-slide="log">
            <code-fragment data-type="text/markdown" auto="true">
# Afrund ForsÃ¸get

NÃ¥r i er fÃ¦rdige med forsÃ¸get
* Tag batteri-pakken ud af Micro:bitâen for at stoppe den
* Tag den med tilbage til computeren
            </code-fragment>
        </step>

        <!-- This part is back on the computer -->        
        <step name="Sikring" data-slide="find-data">    
            <code-fragment data-type="text/markdown" auto="true">
# Datasikring

Nu skal vi have sikret de indsamlede data. SÃ¥ lÃ¦nge de kun ligger pÃ¥ Micro:bitâen, er der en risiko for at nogen kunne komme til at nulstille den ved at trykke A+B eller slette data pÃ¥ anden vis - f.eks. ved at lÃ¦gge et nyt program ind.

* SÃ¦t Micro:bitâen til en af computerne og find MY_DATA.HTM igen ligesom sidst
* Ser det fornuftigt ud?
* Tryk pÃ¥ âDownloadâ for at hente dataene ud som en CSV-fil og gem filen et godt sted                
            </code-fragment>                 
        </step>        
        <step name="Graph" data-slide="graph">
            <code-fragment data-type="text/markdown" auto="true">
# Gruppens Graf

FÃ¸r vi kan vurdere om kÃ¸leskabet overholder kravene for opbevaring af fÃ¸devarer, er det naturligvis vigtigt, at vi sikrer os at de gemte mÃ¥linger giver mening. Vi skal f.eks. ikke inkludere mÃ¥linger fra fÃ¸r Micro:bitâen blev placeret i kÃ¸leskabet eller mÃ¥linger foretaget efter at forsÃ¸get sluttede.

* PÃ¥ computeren med CSV-filen med mÃ¥lingerne: Tryk her pÃ¥ <button class="upload" style="display: inline-flex;align-items: center;vertical-align: bottom;cursor:pointer"><span class="material-icons-outlined" style="margin-right: 0.25em;">cloud_upload</span> Upload</button> for at vÃ¦lge CSV-filen med mÃ¥ledata
* Indstil grafen, sÃ¥ den viser de rigtige akser, og det rigtige tidsinterval
* Kig pÃ¥ grafen og undersÃ¸g om der er en sammenhÃ¦ng imellem de overlejrede hÃ¦ndelser fra logbogen og den mÃ¥lte temperatur
* Er temperaturen stabil - eller svinger den over tid?
* Var der tidspunkter, hvor temperaturen lÃ¥ uden for FÃ¸devarestyrelsens anbefalinger?
* Kunne vi spare energi, fordi maden er kÃ¸let for meget?

Grafen kan zoomes ved at trÃ¦kke og slippe med musen pÃ¥ det omrÃ¥de man gerne vil kigge pÃ¥, og man kan nulstille zoom med et dobbelt klik pÃ¥ grafen.
            </code-fragment>

            <code-fragment data-type="text/javascript">
                if(fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference. alreadyRun = true;


                let uploadButton = stepReference.querySelector("button.upload");

                uploadButton.addEventListener("click", () => {
                    let fileInput = document.createElement("input");
                    fileInput.setAttribute("type", "file");
                    fileInput.addEventListener("input", async ()=>{
                        if(fileInput.files.length === 0) {
                            return;
                        }

                        if (fileInput.files.length > 1) {
                            alert("Multi upload not supported");
                            return;
                        }

                        let file = fileInput.files[0];

                        if(!file.name.endsWith(".csv")) {
                            alert("Only .csv files supported");
                            return;
                        }

                        await Uploader.upload(location.origin+location.pathname, file, file.name);

                        document.querySelector("slide#graph").setAttribute("data-csv", file.name);
                        runOnScreen("updateSharedJson", {});
                    });
                    fileInput.click();
                });
            </code-fragment>

        </step>        
        <step name="Compare" data-slide="multigraph">
            <code-fragment data-type="text/markdown" auto="true">
# Mere Data

Her er en oversigt over alle de mÃ¥ledata, som klassen har lagt op i systemet for det samme tidsrum. Nogle af mÃ¥lerne var mÃ¥ske et andet sted i samme kÃ¸leskab eller i et helt andet kÃ¸leskab.

* Kig pÃ¥ graferne, og vurder om der er nogen sammenhÃ¦ng imellem dem
* Er der bestemte steder, der hele tiden er meget varmere/koldere?
* Er der mÃ¸nstre, der gÃ¥r igen pÃ¥ alle graferne?

Grafen kan zoomes ved at trÃ¦kke og slippe med musen pÃ¥ det omrÃ¥de man gerne vil kigge pÃ¥, og man kan nulstille zoom med et dobbelt klik pÃ¥ grafen.
            </code-fragment>
        </step>



        <step name="PrepHome" data-slide="code" data-slide-mode="homelogger">
            <code-fragment data-type="text/markdown" auto="true">
# Dit KÃ¸leskab

Det er ikke kun for cafÃ©er og restaurenter i professionelle miljÃ¸er at der er risiko for at mad kan gÃ¥ til spilde pÃ¥ grund af manglende indsigt i opbevaringstemperaturen. Rigtigt mange kÃ¸leskabe
i danske hjem er indstillet uhensigtsmÃ¦ssigt eller decideret forkert. 

Det skyldes dog ikke nÃ¸dvendigvis ond vilje fra forbrugeren. PÃ¥ nogle kÃ¸leskabe er kompressorindstillingen mÃ¦rket med tallene 1-6, et antal streger eller med bogstaver. Det er ofte uklart for forbrugeren
om man skal skrue op eller ned for at fÃ¥ en lavere temperatur. F.eks. tolker nogle kÃ¸leskabe indstillingen "5" som vÃ¦rende et Ã¸nske om 5Â°C inde i kÃ¸leskabet, hvor indstillingen "2" (2Â°C) derfor naturligt 
vil give en lavere temperatur. Modsat tolker nogle kÃ¸leskabe "5" som vÃ¦rende den hÃ¸jeste kompressorhastighed, hvor indstillingen "2" derfor sÃ¦tter kÃ¸leskabet til at kÃ¸le med under halv kraft, resulterende i
i en vÃ¦sentligt hÃ¸jere temperatur for madvarerne.

Baseret pÃ¥ det oprindelige termometer-program uden klima-modul, som vi i starten af forlÃ¸bet byggede til Micro:bit'en, kan vi lave en smartere mÃ¥ler som alle i gruppen hver isÃ¦r kan tage med hjem.

Lige som for mÃ¥leren vi byggede til klima-modulet har vi tilfÃ¸jet muligheden for at nulstille loggen ved at holde A+B nede samtidigt. Der er dog nogle andre udfordringer:
Micro:bit'en kan ikke gemme uendeligt meget data, faktisk kun omkring 11300 mÃ¥lepunkter nÃ¥r man gemmer temperaturen. Derudover koster det meget strÃ¸m at holde LED-displayet tÃ¦ndt.

* ModificÃ©r programmet sÃ¥ det ikke logger data helt sÃ¥ ofte. - f.eks. sÃ¥ i er sikre pÃ¥ at det uden problemer kan logge data i et helt dÃ¸gn uden at lÃ¸be tÃ¸r for plads
* Lav Ã¦ndringer i programmet sÃ¥ det ikke lÃ¦ngere altid viser temperaturen pÃ¥ LED-displayet nÃ¥r det logger en mÃ¥ling men kun viser temperaturen kortvarigt hvis man trykker pÃ¥ A-knappen?
* Hvis i har god tid: Overvej om man kan tilfÃ¸je en alarm som laver et kort bip efter hver mÃ¥ling hvis temperaturen er alt for hÃ¸j - f.eks. hvis kÃ¸leskabet er gÃ¥et i stykker eller hvis nogen har glemt at lukke dÃ¸ren
* LÃ¦g programmet pÃ¥ jeres Micro:bits, opfÃ¸rer det sig som forventet?

Hvis i kommer til at Ã¸delÃ¦gge koden, sÃ¥ den ikke virker korrekt mere, kan i trykke <a class="codeResetButton" href="#">her</a> for at genskabe den oprindelige kode.
            </code-fragment>
            <code-fragment data-type="text/javascript">
                if(fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference. alreadyRun = true;

                stepReference.querySelector(".codeResetButton").addEventListener("click", ()=>{
                    runOnScreen("resetCurrentMakeCodeFragment");
                });
            </code-fragment>
            <code-fragment id="homie" data-type="application/json" data-restrict="homie">
{
  "header": {
    "name": "Untitled",
    "meta": {"caviId": "homie"},
    "editor": "blocksprj",
    "pubId": "",
    "pubCurrent": false,
    "target": "microbit",
    "targetVersion": "5.0.15",
    "id": "9dd7dc9b-6bdc-48b5-3dda-c70b9be47a9a",
    "recentUse": 1670575165,
    "modificationTime": 1670575165,
    "path": "Untitled-15",
    "cloudCurrent": false,
    "saveId": null,
    "githubCurrent": false
  },
  "text": {
    "README.md": "",
    "main.blocks": "<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"every_interval\" x=\"38\" y=\"24\"><value name=\"interval\"><shadow type=\"longTimePicker\"><field name=\"ms\">1000</field></shadow></value><statement name=\"HANDLER\"><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"device_temperature\"></block></value><next><block type=\"dataloggerlog\" inline=\"true\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"data1\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"temp\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"device_temperature\"></block></value></shadow></value><value name=\"data2\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data3\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data4\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data5\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data6\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data7\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data8\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data9\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value><value name=\"data10\"><shadow type=\"dataloggercreatecolumnvalue\"><value name=\"column\"><shadow type=\"datalogger_columnfield\"><field name=\"column\">\"\"</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></shadow></value></block></next></block></statement></block><block type=\"device_button_event\" x=\"567\" y=\"23\"><field name=\"NAME\">Button.AB</field><statement name=\"HANDLER\"><block type=\"dataloggerdeletelog\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"deleteType\">datalogger.DeleteType.Fast</field><next><block type=\"basic_show_icon\"><field name=\"i\">IconNames.Yes</field><next><block type=\"device_clear_display\"><next><block type=\"control_reset\"></block></next></block></next></block></next></block></statement></block></xml>",
    "main.ts": "input.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.Yes)\n    basic.clearScreen()\n    control.reset()\n})\nloops.everyInterval(1000, function () {\n    basic.showNumber(input.temperature())\n    datalogger.log(datalogger.createCV(\"temp\", input.temperature()))\n})\n",
    "pxt.json": "{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"blocksprj\"}\n"
  }
}
            </code-fragment> 
        </step>
        <step name="HomeGraph" data-slide="home">    
            <code-fragment data-type="text/markdown" auto="true">
# Check KÃ¸leskabet (Hjemmearbejde)

Dette skridt foregÃ¥r i jeres kÃ¸leskabe derhjemme. Det kan vÃ¦re en god idÃ© at fortÃ¦lle resten af familien om eksperimentet sÃ¥ de ikke bliver overraskede nÃ¥r de Ã¥bner lÃ¥gen.

* LÃ¦g Micro:bit'en i kÃ¸leskabet og start en frisk mÃ¥ling ved at holde A+B nede samtidigt. Luk lÃ¥gen.
* Lav noget andet i mindst 1 time, sÃ¥ mÃ¥leren og kÃ¸leskabet nÃ¥r at finde en nogenlunde fast temperatur
* Check nu mÃ¥leren ved at trykke pÃ¥ A-knappen (Pas pÃ¥ ikke at slette mÃ¥lingerne ved ogsÃ¥ at trykke pÃ¥ B!). Overholder kÃ¸leskabet FÃ¸devarestyrelsens anbefalede temperatur til at begynde med?
* Bliver det varmere eller koldere hvis man "skruer op" pÃ¥ kompressor-indstillingen og venter mindst 1 time?
* Hvad er den bedste indstilling som hverken er for kold eller for varm? (efter 1 time...)

NÃ¥r i har hentet dataene ud af Micro:bit'en kan i omdÃ¸be CSV-filen til noget fornuftigt og trÃ¦kke den ned i upload-feltet herunder for at dele den med gruppen:

I nÃ¦ste undervisningslektion skal vi i fÃ¦llesskab pÃ¥ klassen kigge pÃ¥ hvordan man uden for CoTinker behandler de data i har optaget fra jeres kÃ¸leskab.
            </code-fragment>                 
            <div class="imageAssetUploader">
        	<!-- Prefill with relevant existing assets that cannot be deleted -->
            </div>
            <code-fragment data-type="text/javascript">
                if(fragmentSelfReference.alreadyRun) {
                    return;
                }
                fragmentSelfReference. alreadyRun = true;

                CoTinkerAssetUploader.prepareUploadArea(stepReference.querySelector(".imageAssetUploader"));
            </code-fragment>
        </step>
    </steps>
    <code-fragment data-type="text/javascript" auto="auto">                
        let link = window.location.href.split('?')[0] + "?mobile&controllerOnly";
        await WPMv2.require([{package: "qrcodejs", repository: "wpm_js_libs"}]);
        let target = document.getElementById("htmlqrcode");
        new QRCode(target, {
            text: link,
            width: 2560,
            height: 2560,
            colorDark: "#000000",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.H
        });            
    </code-fragment>            
</assignment>
